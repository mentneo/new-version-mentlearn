import { db } from '../firebase/firebase';
import { doc, setDoc, updateDoc, collection, addDoc, serverTimestamp, getDoc } from 'firebase/firestore';

// Razorpay API key
const RAZORPAY_KEY = 'rzp_live_IobJO4qxEvr6cM'; // Production key

class RazorpayService {
  constructor() {
    this.loadScript();
  }

  loadScript() {
    return new Promise((resolve, reject) => {
      if (window.Razorpay) {
        console.log('Razorpay already loaded');
        resolve();
        return;
      }

      const script = document.createElement('script');
      script.src = 'https://checkout.razorpay.com/v1/checkout.js';
      script.async = true;
      
      script.onload = () => {
        console.log('Razorpay script loaded successfully');
        resolve();
      };
      
      script.onerror = (error) => {
        console.error('Failed to load Razorpay script:', error);
        reject(new Error('Failed to load Razorpay payment gateway. Please refresh the page or try again later.'));
      };
      
      document.body.appendChild(script);
    });
  }

  async createOrder(amount, userData, courseData = null, isCustomAmount = false) {
    try {
      // Create an order in Firestore first
      const orderRef = await addDoc(collection(db, 'razorpayOrders'), {
        amount: amount * 100, // Convert to paisa
        currency: 'INR',
        userId: userData.id,
        status: 'created',
        createdAt: serverTimestamp(),
        plan: userData.plan || 'complete',
        isCustomAmount: isCustomAmount,
        courseId: courseData?.id || null,
        courseName: courseData?.name || null,
        courseType: courseData?.type || null

  async processPayment(orderData, userData, successCallback, failureCallback) {
    try {
      await this.loadScript();
      
      if (!window.Razorpay) {
        console.error('Razorpay not available after loading script');
        throw new Error('Payment gateway not available. Please refresh and try again.');
      }

      console.log('Configuring Razorpay payment options');
      
      // Verify orderData has required fields
      if (!orderData || !orderData.id || !orderData.amount) {
        console.error('Invalid order data:', orderData);
        throw new Error('Invalid payment information. Please try again.');
      }
      
      // Get plan name for description
      let planName;
      if (isCustomAmount) {
        planName = 'Custom Payment';
      } else if (userData.plan && userData.plan.startsWith('course_')) {
        planName = 'Course Enrollment';
      } else {
        planName = userData.plan === 'basic' ? 'Basic Plan' : 'Complete Bundle';
      }

      // Configure payment options
      const options = {
        key: RAZORPAY_KEY,
        amount: orderData.amount,
        currency: orderData.currency,
        name: 'Mentneo',
        description: `Payment for ${orderData.courseName || 'course'}`,
        order_id: orderData.id,
        prefill: {
          name: userData.name || '',
          email: userData.email || '',
          contact: userData.phone || ''
        },
        theme: {
          color: '#4F46E5'
        },
        modal: {
          confirm_close: true,
          ondismiss: () => {
            if (failureCallback) {
              failureCallback({
                message: "Payment cancelled by user",
                code: "PAYMENT_CANCELLED",
                source: "user"
              });
            }
          }
        },
        handler: async (response) => {
          try {
            console.log('Payment success response:', response);
            
            try {
              if (isDemoMode) {
                console.log("DEMO MODE: Skipping database operations");
                if (successCallback) {
                  successCallback(response, { verified: true, demo: true });
                }
                return;
              }
              
              // Verify payment signature
              const isValidPayment = this.verifyPaymentSignature(response);
              if (!isValidPayment) {
                throw new Error('Invalid payment signature');
              }

              // Update payment status in Firestore
              await this.updatePaymentStatus(
                orderData.id, 
                'success', 
                response.razorpay_payment_id,
                userData.id,
                userData.plan || 'complete',
                null,
                isCustomAmount,
                orderData.amount / 100 // Convert back from paisa to rupees
              );

              // Send notification to admin
              await addDoc(collection(db, 'adminNotifications'), {
                type: 'payment_success',
                courseId: orderData.courseId,
                courseName: orderData.courseName,
                userId: userData.id,
                userName: userData.name,
                amount: orderData.amount / 100,
                paymentId: response.razorpay_payment_id,
                createdAt: serverTimestamp(),
                status: 'unread',
                title: 'New Course Payment',
                message: `${userData.name} has enrolled in ${orderData.courseName}`,
              });
              
              // Grant access to courses
              await this.enrollUserInCourses(userData.id, userData.plan || 'complete', isCustomAmount);
              
              if (successCallback) {
                successCallback(response, { verified: true });
              }
            } catch (dbError) {
              console.error('Database error after payment:', dbError);
              
              // Check if it's a permission error
              if (failureCallback) {
                // Handle other errors
                if (failureCallback) {
                  failureCallback({
                    message: "Payment was successful, but there was an issue updating your enrollment. Please contact support with your payment ID: " + response.razorpay_payment_id,
                    code: "DATABASE_ERROR",
                    source: "database",
                    paymentId: response.razorpay_payment_id
                  });
                }
              }
            }
          } catch (error) {
            console.error('Error handling successful payment:', error);
            
            if (failureCallback) {
              failureCallback(error);
            }
          }
        },
        prefill: {
          name: userData.name || '',
          email: userData.email || '',
          contact: userData.phone || ''
        },
        notes: {
          userId: userData.id,
          planId: userData.plan || 'complete'
        },
        theme: {
          color: '#4568dc'
        }
      };

      console.log('Creating Razorpay instance with options:', { ...options, key: '[HIDDEN]' });
      const razorpay = new window.Razorpay(options);
      
      // Add more event listeners for better error handling
      razorpay.on('payment.failed', async (response) => {
        console.error('Payment failed:', response);
        
        await this.updatePaymentStatus(
          orderData.id, 
          'failed', 
          response.error?.metadata?.payment_id || null,
          userData.id,
          userData.plan || 'complete',
          response.error?.description || "Payment failed",
          isCustomAmount
        );
        
        if (failureCallback) {
          failureCallback({
            message: response.error?.description || "Payment failed",
            code: response.error?.code || "UNKNOWN_ERROR",
            source: "razorpay",
            metadata: response.error?.metadata || {}
          });
        }
      });
      
      // Add more events for debugging
      razorpay.on('payment.cancel', () => {
        console.log('Payment cancelled by user');
        
        if (failureCallback) {
          failureCallback({
            message: "Payment was cancelled",
            code: "PAYMENT_CANCELLED",
            source: "user"
          });
        }
      });
      
      console.log('Opening Razorpay payment dialog');
      razorpay.open();
      return true;
    } catch (error) {
      console.error('Error processing payment:', error);
      
      // More specific error handling
      let errorToReport = error;
      if (error.message === 'Network Error') {
        errorToReport = new Error('Network connection issue. Please check your internet and try again.');
      }
      
      if (failureCallback) {
        failureCallback(errorToReport);
      } else {
        throw errorToReport;
      }
    }
  }

  async updatePaymentStatus(orderId, status, paymentId, userId, courseId) {
    try {
      if (!orderId || !status || !userId) {
        throw new Error('Missing required parameters for payment status update');
      }

      // Update the order document
      const orderRef = doc(db, 'razorpayOrders', orderId);
      await updateDoc(orderRef, {
        status: status,
        paymentId: paymentId || null,
        userId: userId,
        courseId: courseId || null,
        updatedAt: serverTimestamp()
      });

      // Create a new payment record
      await addDoc(collection(db, 'payments'), {
        orderId: orderId,
        paymentId: paymentId,
        userId: userId,
        courseId: courseId || null,
        status: status,
        provider: 'razorpay',
        timestamp: serverTimestamp()
      });

      return true;
    } catch (error) {
      console.error('Error updating payment status:', error);
      throw new Error(`Failed to update payment status: ${error.message}`);
    }
  }

  async enrollUserInCourse(userId, courseId) {
    try {
      // Check user permissions before enrolling
      try {
        const userRef = doc(db, "users", userId);
        const userSnapshot = await getDoc(userRef);
        
        if (userSnapshot.exists()) {
          const userData = userSnapshot.data();
          if (userData.role === 'banned' || userData.role === 'suspended') {
            throw new Error("Your account doesn't have permission to enroll in courses");
          }
        }
      } catch (permError) {
        console.error("Permission check error during enrollment:", permError);
        // If it's not a permission error, continue with enrollment
        if (permError.message.includes('permission')) {
          throw permError;
        }
      }
      
      // Create enrollment document with pending status
      try {
        await addDoc(collection(db, 'enrollments'), {
          userId: userId,
          courseId: courseId,
          status: 'active',
          enrolledAt: serverTimestamp(),
          accessUntil: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000) // 1 year access
        });
      } catch (enrollError) {
        console.error("Error creating enrollment:", enrollError);
        if (enrollError.code === "permission-denied") {
          throw new Error("Permission denied: Unable to create enrollment. Please contact support.");
        }
        throw new Error("Failed to create enrollment: " + enrollError.message);
      }
      
      // Update user document to mark as paid but pending verification
      try {
        const userRef = doc(db, 'users', userId);
        await updateDoc(userRef, {
          hasPaid: true,
          verificationStatus: 'pending', // Add verification status
          accessGranted: false, // Don't grant access until verified by admin
          accessLevel: null, // Will be set when verified
          planId: planId,
          customAmountPayment: isCustomAmount,
          paymentCompleted: true, // New flag indicating payment is complete
          updatedAt: serverTimestamp()
        });
      } catch (userUpdateError) {
        console.error("Error updating user:", userUpdateError);
        if (userUpdateError.code === "permission-denied") {
          throw new Error("Permission denied: Unable to update user status. Please contact support.");
        }
        throw new Error("Failed to update user status: " + userUpdateError.message);
      }
      
      // Create notification for admin
      try {
        await addDoc(collection(db, 'adminNotifications'), {
          type: 'new_payment',
          userId: userId,
          planId: planId,
          isCustomAmount: isCustomAmount,
          status: 'unread',
          createdAt: serverTimestamp(),
          message: `New ${isCustomAmount ? 'custom amount' : ''} payment received. Student access pending verification.`
        });
      } catch (notifyError) {
        // Just log the notification error but don't fail the enrollment
        console.error("Error creating admin notification:", notifyError);
      }
      
      return true;
    } catch (error) {
      console.error('Error enrolling user:', error);
      throw error;
    }
  }

  verifyPaymentSignature(response) {
    if (!response.razorpay_payment_id || !response.razorpay_order_id || !response.razorpay_signature) {
      console.error('Missing required payment verification fields');
      return false;
    }

    try {
      // Get signature fields
      const { razorpay_order_id, razorpay_payment_id, razorpay_signature } = response;

      // Build signature validation string
      const signatureString = `${razorpay_order_id}|${razorpay_payment_id}`;

      // In production, make an API call to your backend to verify the signature
      // The backend should use Razorpay's SDK to verify the signature
      // Example backend endpoint: '/api/verify-razorpay-signature'
      
      // For now, validate at least the fields are present and well-formed
      if (!razorpay_signature.match(/^[a-f0-9]{40}$/i)) {
        console.error('Invalid signature format');
        return false;
      }

      // TODO: Replace with actual server-side verification
      // const response = await fetch('/api/verify-razorpay-signature', {
      //   method: 'POST',
      //   headers: { 'Content-Type': 'application/json' },
      //   body: JSON.stringify({ orderId: razorpay_order_id, paymentId: razorpay_payment_id, signature: razorpay_signature })
      // });
      // return response.ok;

      return true;
    } catch (error) {
      console.error('Payment signature verification failed:', error);
      return false;
    }
  }
}
}

// Create instance and export
const razorpayService = new RazorpayService();
export default razorpayService;
